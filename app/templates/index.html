<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CoachV2 Dashboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body data-unit-value="{{ unit_value }}" data-timezone="{{ display_timezone }}">
    <header class="app-header">
      <div>
        <h1>CoachV2</h1>
        <p class="subtitle">Reverse moneyline movement monitor</p>
      </div>
      <div class="actions" role="region" aria-label="Dashboard controls">
        <div class="control-group">
          <label for="limit-select">Show</label>
          <select id="limit-select">
            <option value="25">25</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
          </select>
        </div>
        <div class="control-group">
          <label for="league-select">League</label>
          <select id="league-select">
            <option value="all" selected>All</option>
          </select>
        </div>
        <div class="control-group">
          <label for="book-select">Sportsbook</label>
          <select id="book-select">
            <option value="all" selected>All</option>
          </select>
        </div>
        <div class="control-group">
          <label for="confidence-select">Confidence</label>
          <select id="confidence-select">
            <option value="all" selected>All</option>
            <option value="high">High</option>
            <option value="medium">Medium</option>
            <option value="low">Low</option>
          </select>
        </div>
        <button id="refresh-btn" type="button">Refresh</button>
        <button
          id="ingest-btn"
          type="button"
          class="primary"
          title="Triggers an immediate odds pull from configured books. Use when you want the latest lines outside the twice-daily schedule."
        >
          Run Ingestion
        </button>
      </div>
    </header>

    <main>
      <div class="view-switch" role="tablist" aria-label="Recommendation views">
        <button type="button" class="tab-btn active" data-view="live" role="tab" aria-selected="true">
          Live Recommendations
        </button>
        <button type="button" class="tab-btn" data-view="history" role="tab" aria-selected="false">
          History
        </button>
      </div>

      <section class="status-bar" id="status-bar">
        <span id="status-message">Loading recommendations…</span>
      </section>

      <section class="explain-panel">
        <div class="panel-title">
          When should I bet?
          <span class="info-icon" data-tooltip="CoachV2 flags reverse line moves where the underdog price tightens past your threshold.">i</span>
        </div>
        <ul>
          <li><strong>We’re always betting the dog.</strong> The recommendation points to whichever side’s moneyline tightened. “Home” or “away” just tells you which dugout the dog sits in.</li>
          <li><strong>Gold rows = market agreement.</strong> When more than one book shows the same reverse move, we highlight the row and automatically bump confidence.</li>
          <li><strong>Confidence tiers.</strong> “High” needs either a monster move (≥ threshold × high multiplier) or multi-book confirmation. “Medium” lands between the medium and high multipliers. Anything smaller stays “Low.”</li>
          <li><strong>Verify the narrative.</strong> Reverse moves usually mean sharp action, but still double-check injuries, lineups, and weather before placing a ticket. The matchup tooltip gives start time.</li>
          <li><strong>Track what you fire.</strong> Log the bets you actually play so we can review ROI by confidence, book, and sport.</li>
        </ul>
        <p class="ingest-note">
          <strong>Run Ingestion</strong> pulls fresh odds immediately. It’s helpful before placing bets or if you suspect the market has moved since the last scheduled sweep.
        </p>
      </section>

      <section class="table-container">
        <table id="recommendations-table">
          <thead>
            <tr>
              <th scope="col" data-sort="triggered_at">Triggered <span class="sort-indicator"></span></th>
              <th scope="col" data-sort="league">League <span class="sort-indicator"></span></th>
              <th scope="col">Matchup</th>
              <th scope="col" data-sort="sportsbook">Sportsbook <span class="sort-indicator"></span></th>
              <th scope="col" data-sort="bet_side">Recommendation <span class="sort-indicator"></span></th>
              <th scope="col" data-sort="movement">Odds Move <span class="sort-indicator"></span></th>
              <th scope="col" data-sort="confidence">Confidence <span class="sort-indicator"></span></th>
              <th scope="col" data-sort="outcome">Outcome <span class="sort-indicator"></span></th>
              <th scope="col">Logged Units</th>
              <th scope="col">Action</th>
            </tr>
          </thead>
          <tbody id="recommendations-body"></tbody>
        </table>
      </section>
    </main>

    <template id="row-template">
      <tr>
        <td class="triggered"></td>
        <td class="league"></td>
        <td class="matchup"></td>
        <td class="sportsbook"></td>
        <td class="side"></td>
        <td class="movement"></td>
        <td class="confidence"></td>
        <td class="outcome"></td>
        <td class="logged-sum"></td>
        <td class="bet-action"></td>
      </tr>
    </template>

    <script>
      const API_BASE = '/api';
      const displayTimezone = document.body.dataset.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
      const tableBody = document.getElementById('recommendations-body');
      const statusMessage = document.getElementById('status-message');
      const limitSelect = document.getElementById('limit-select');
      const leagueSelect = document.getElementById('league-select');
      const bookSelect = document.getElementById('book-select');
      const confidenceSelect = document.getElementById('confidence-select');
      const refreshBtn = document.getElementById('refresh-btn');
      const ingestBtn = document.getElementById('ingest-btn');
      const rowTemplate = document.getElementById('row-template');
      const headerCells = document.querySelectorAll('th[data-sort]');
      const tabButtons = document.querySelectorAll('.tab-btn');
      tabButtons.forEach((button) => {
        button.setAttribute('aria-selected', button.classList.contains('active'));
      });
      let unitValue = parseFloat(document.body.dataset.unitValue || '1');

      const state = {
        data: [],
        filters: {
          league: 'all',
          sportsbook: 'all',
          confidence: 'all',
        },
        sort: {
          key: 'triggered_at',
          direction: 'desc',
        },
        lastRefreshed: null,
        view: 'live',
      };

      const confidenceOrder = { high: 3, medium: 2, low: 1 };
      const movementPriority = { reverse: 2, favorite: 1, unchanged: 0 };

      async function fetchRecommendations() {
        statusMessage.textContent = 'Loading recommendations…';
        tableBody.innerHTML = '';
        try {
          const limit = limitSelect.value;
          const scope = state.view === 'history' ? 'history' : 'live';
          const response = await fetch(`${API_BASE}/recommendations?scope=${scope}&limit=${limit}`);
          if (!response.ok) {
            throw new Error(`API error ${response.status}`);
          }
          const data = await response.json();
          if (data.length && data[0].unit_value) {
            unitValue = parseFloat(data[0].unit_value) || unitValue;
            document.body.dataset.unitValue = unitValue;
          }
          state.data = data;
          state.lastRefreshed = new Date();
          populateFilterOptions(data);
          applyFiltersAndRender();
        } catch (err) {
          console.error(err);
          statusMessage.textContent = 'Failed to load recommendations. Check logs and try again.';
        }
      }

      function populateFilterOptions(data) {
        const leagueValues = new Set(['all']);
        const bookValues = new Set(['all']);
        const confidenceValues = new Set(['all', 'high', 'medium', 'low']);

        for (const rec of data) {
          if (rec.event?.league) {
            leagueValues.add(rec.event.league);
          } else if (rec.event?.sport_key) {
            leagueValues.add(rec.event.sport_key);
          }
          if (rec.sportsbook_name || rec.sportsbook) {
            bookValues.add(rec.sportsbook_name || rec.sportsbook);
          }
          if (rec.confidence) {
            confidenceValues.add(rec.confidence.toLowerCase());
          }
        }

        updateSelectOptions(leagueSelect, leagueValues, state.filters.league);
        updateSelectOptions(bookSelect, bookValues, state.filters.sportsbook);
        updateSelectOptions(confidenceSelect, confidenceValues, state.filters.confidence, true);

        state.filters.league = leagueSelect.value;
        state.filters.sportsbook = bookSelect.value;
        state.filters.confidence = confidenceSelect.value.toLowerCase();
      }

      function updateSelectOptions(selectEl, values, currentValue, enforceOrder = false) {
        const options = Array.from(values);
        if (enforceOrder) {
          const order = ['all', 'high', 'medium', 'low'];
          options.sort((a, b) => order.indexOf(a) - order.indexOf(b));
        } else {
          options.sort((a, b) => a.localeCompare(b));
        }
        selectEl.innerHTML = '';
        for (const value of options) {
          const opt = document.createElement('option');
          opt.value = value;
          const label = value === 'all' ? 'All' : (enforceOrder ? capitalize(value) : value);
          opt.textContent = label;
          if (value === currentValue) {
            opt.selected = true;
          }
          selectEl.appendChild(opt);
        }
      }

      function applyFiltersAndRender() {
        const filtered = state.data.filter((rec) => {
          const matchesLeague =
            state.filters.league === 'all' ||
            (rec.event?.league && rec.event.league === state.filters.league) ||
            (rec.event?.sport_key && rec.event.sport_key === state.filters.league);

          const matchesBook =
            state.filters.sportsbook === 'all' ||
            rec.sportsbook_name === state.filters.sportsbook ||
            rec.sportsbook === state.filters.sportsbook;

          const matchesConfidence =
            state.filters.confidence === 'all' ||
            (rec.confidence && rec.confidence.toLowerCase() === state.filters.confidence);

          return matchesLeague && matchesBook && matchesConfidence;
        });

        const sorted = sortRecommendations(filtered, state.sort);
        renderRecommendations(sorted);
        updateSortIndicators();
        updateStatusSummary(sorted);
      }

      function sortRecommendations(recommendations, sort) {
        const { key, direction } = sort;
        const multiplier = direction === 'asc' ? 1 : -1;

        return recommendations.slice().sort((a, b) => {
          const valA = getSortValue(a, key);
          const valB = getSortValue(b, key);

          if (valA < valB) return -1 * multiplier;
          if (valA > valB) return 1 * multiplier;
          return 0;
        });
      }

      function getSortValue(rec, key) {
        switch (key) {
          case 'triggered_at':
            return rec.triggered_at ? new Date(rec.triggered_at).getTime() : 0;
          case 'league':
            return rec.event?.league || rec.event?.sport_key || '';
          case 'sportsbook':
            return (rec.sportsbook_name || rec.sportsbook || '').toLowerCase();
          case 'bet_side':
            return rec.team ? rec.team.toLowerCase() : rec.bet_side || '';
          case 'movement':
            return rec.movement ? movementPriority[rec.movement] || 0 : 0;
          case 'confidence':
            return rec.confidence ? confidenceOrder[rec.confidence] || 0 : 0;
          case 'outcome':
            if (!rec.outcome) return 0;
            const outcomeOrder = { won: 3, push: 2, void: 1, lost: 0 };
            return outcomeOrder[rec.outcome] ?? 0;
          default:
            return 0;
        }
      }

      function renderRecommendations(recommendations) {
        tableBody.innerHTML = '';

        if (!recommendations.length) {
          const emptyRow = rowTemplate.content.cloneNode(true);
          emptyRow.querySelector('.triggered').textContent = '—';
          emptyRow.querySelector('.league').textContent = '—';
          emptyRow.querySelector('.matchup').textContent = 'No recommendations match your filters yet.';
          emptyRow.querySelector('.sportsbook').textContent = '—';
          emptyRow.querySelector('.side').textContent = '—';
          emptyRow.querySelector('.movement').textContent = '—';
          emptyRow.querySelector('.confidence').textContent = '—';
          emptyRow.querySelector('.outcome').textContent = '—';
          emptyRow.querySelector('.logged-sum').textContent = '—';
          emptyRow.querySelector('.bet-action').textContent = '—';
          tableBody.appendChild(emptyRow);
          return;
        }

        const eventCounts = recommendations.reduce((acc, rec) => {
          const key = rec.event?.id;
          if (!key) return acc;
          acc[key] = (acc[key] || 0) + 1;
          return acc;
        }, {});

        for (const rec of recommendations) {
          const row = rowTemplate.content.cloneNode(true);
          row.querySelector('.triggered').textContent = formatDate(rec.triggered_at);
          row.querySelector('.league').textContent = rec.event?.league || rec.event?.sport_key || '—';
          row.querySelector('.matchup').innerHTML = formatMatchup(rec);
          row.querySelector('.sportsbook').textContent = rec.sportsbook_name || rec.sportsbook || '—';
          row.querySelector('.side').innerHTML = formatRecommendation(rec);
          row.querySelector('.movement').textContent = formatMovement(rec);
          row.querySelector('.confidence').textContent = rec.confidence || '—';
          const outcomeCell = row.querySelector('.outcome');
          outcomeCell.textContent = formatOutcome(rec);
          outcomeCell.className = 'outcome';
          if (rec.outcome) {
            outcomeCell.classList.add(`outcome-${rec.outcome}`);
          }
          row.querySelector('.logged-sum').textContent = formatLoggedSummary(rec);
          const rowElement = row.querySelector('tr');
          rowElement.classList.remove('multi-book', 'result-won', 'result-lost', 'result-push', 'result-void');
          const multiBookFlag = rec.details?.multi_book_confirmed;
          if ((rec.event?.id && eventCounts[rec.event.id] > 1) || multiBookFlag) {
            rowElement.classList.add('multi-book');
            rowElement.title = 'Same game flagged by multiple books';
          }
          if (rec.outcome) {
            rowElement.classList.add(`result-${rec.outcome}`);
          }
          renderActionCell(rowElement, rec);
          tableBody.appendChild(row);
        }
      }

      function updateSortIndicators() {
        headerCells.forEach((cell) => {
          const indicator = cell.querySelector('.sort-indicator');
          indicator.textContent = '';
          const key = cell.dataset.sort;
          if (!key) return;
          if (state.sort.key === key) {
            indicator.textContent = state.sort.direction === 'asc' ? '▲' : '▼';
          }
        });
      }

      function formatMatchup(rec) {
        if (!rec.event) {
          return '—';
        }
        const home = rec.event.home_team || 'Home';
        const away = rec.event.away_team || 'Away';
        const time = rec.event.commence_time
          ? formatDatetime(rec.event.commence_time)
          : '';
        const score = formatScore(rec);
        const scoreLine = score ? `<br/><span class="muted">${score}</span>` : '';
        return `<strong>${away}</strong> @ <strong>${home}</strong><br/><span class="muted">${time}</span>${scoreLine}`;
      }

      function formatDate(value) {
        if (!value) return '—';
        return formatDatetime(value);
      }

      function formatDatetime(value) {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toLocaleString('en-US', { timeZone: displayTimezone });
      }

      function capitalize(word) {
        if (!word) return word;
        return word.charAt(0).toUpperCase() + word.slice(1);
      }

      function formatAmericanOdds(value) {
        if (value === null || value === undefined) {
          return 'N/A';
        }
        const num = Number(value);
        if (Number.isNaN(num)) {
          return String(value);
        }
        return num > 0 ? `+${num}` : `${num}`;
      }

      function formatRecommendation(rec) {
        const team = rec.team || capitalize(rec.bet_side) || 'Unknown side';
        const currentPrice = rec.details?.current_price;
        const odds = formatAmericanOdds(currentPrice);

        const descriptors = [];
        if (rec.movement === 'reverse') descriptors.push('reverse signal');
        if (rec.bet_side === 'home' || rec.bet_side === 'away') {
          descriptors.push(`${rec.bet_side} side`);
        }

        const suffix = descriptors.length
          ? `<span class="muted-inline"> (${descriptors.join(', ')})</span>`
          : '';

        return `Bet ${team} ML @ ${odds}${suffix}`;
      }

      function formatMovement(rec) {
        const prev = rec.details?.previous_price;
        const curr = rec.details?.current_price;
        if (prev === undefined || prev === null || curr === undefined || curr === null) {
          return rec.movement ? capitalize(rec.movement) : '—';
        }
        return `${formatAmericanOdds(prev)} → ${formatAmericanOdds(curr)}`;
      }

      function formatOutcome(rec) {
        if (rec.outcome) {
          const label = capitalize(rec.outcome);
          const score = formatScore(rec);
          return score ? `${label} ${score}` : label;
        }
        return state.view === 'history' ? 'Pending' : '—';
      }

      function formatScore(rec) {
        if (!rec.event) return '';
        const { home_score: homeScore, away_score: awayScore } = rec.event;
        if (homeScore === null || homeScore === undefined || awayScore === null || awayScore === undefined) {
          return '';
        }
        const homeTeam = rec.event.home_team || 'Home';
        const awayTeam = rec.event.away_team || 'Away';
        return `(Final ${awayTeam} ${awayScore} - ${homeTeam} ${homeScore})`;
      }

      function renderActionCell(rowElement, rec) {
        const cell = rowElement.querySelector('.bet-action');
        if (!cell) return;

        cell.innerHTML = '';

        const logButton = document.createElement('button');
        logButton.type = 'button';
        logButton.className = 'log-bet-btn';

        if (rec.bet_logged) {
          logButton.textContent = 'Logged';
          logButton.disabled = true;
        } else {
          logButton.textContent = 'Log Bet';
          logButton.addEventListener('click', () => logBet(rec, logButton));
        }

        cell.appendChild(logButton);

        if (state.view === 'history') {
          if (!rec.outcome) {
            const resolveBtn = document.createElement('button');
            resolveBtn.type = 'button';
            resolveBtn.className = 'resolve-btn';
            resolveBtn.textContent = 'Set Outcome';
            resolveBtn.addEventListener('click', () => resolveRecommendation(rec));
            cell.appendChild(resolveBtn);
          }
        }

        if (!cell.children.length) {
          cell.textContent = '—';
        }
      }

      async function logBet(rec, button) {
        try {
          const defaultStake = rec.bets?.[0]?.stake_units || 1;
          const stakeInput = prompt('Stake (units)', defaultStake);
          if (stakeInput === null) return;

          const oddsSuggestion = rec.details?.current_price ?? '';
          const priceInput = prompt('Odds (American)', oddsSuggestion);
          if (priceInput === null) return;

          const notesInput = prompt('Notes (optional)', '');

          button.disabled = true;
          button.textContent = 'Saving…';

          const response = await fetch(`${API_BASE}/recommendations/${rec.id}/bets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              stake: stakeInput,
              price: priceInput,
              notes: notesInput,
            }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error || `Request failed (${response.status})`);
          }

          const result = await response.json();

          const unitsLogged = parseFloat(result.stake_units) || parseFloat(stakeInput) || 0;
          const amountLogged = parseFloat(result.stake_amount) || unitsLogged * unitValue;

          rec.bet_logged = true;
          rec.bet_count = (rec.bet_count || 0) + 1;
          rec.bets = rec.bets || [];
          rec.bets.push({
            stake_units: unitsLogged,
            stake_amount: amountLogged,
            price: parseFloat(priceInput),
            notes: notesInput,
          });

          button.textContent = 'Logged';
          button.disabled = true;
          statusMessage.textContent = `Logged ${unitsLogged.toFixed(2)}U (${formatCurrency(amountLogged)}) on ${rec.team || rec.bet_side} (${rec.sportsbook_name || rec.sportsbook}).`;
          applyFiltersAndRender();
        } catch (err) {
          console.error(err);
          alert(err.message || 'Failed to log bet.');
          button.disabled = false;
          button.textContent = 'Log Bet';
        }
      }

      async function resolveRecommendation(rec) {
        try {
          const outcomeInput = prompt('Outcome (won/lost/push/void)', rec.outcome || 'won');
          if (outcomeInput === null) return;

          const normalized = outcomeInput.trim().toLowerCase();
          const allowed = ['won', 'lost', 'push', 'void'];
          if (!allowed.includes(normalized)) {
            alert(`Outcome must be one of: ${allowed.join(', ')}`);
            return;
          }

          const homeScoreInput = prompt('Home score (optional)', rec.event?.home_score ?? '');
          if (homeScoreInput === null) return;
          const awayScoreInput = prompt('Away score (optional)', rec.event?.away_score ?? '');
          if (awayScoreInput === null) return;
          const closingPriceInput = prompt('Closing price (optional)', rec.closing_price ?? rec.details?.current_price ?? '');
          if (closingPriceInput === null) return;

          const response = await fetch(`${API_BASE}/recommendations/${rec.id}/resolve`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              outcome: normalized,
              home_score: homeScoreInput || null,
              away_score: awayScoreInput || null,
              closing_price: closingPriceInput || null,
            }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error || `Request failed (${response.status})`);
          }

          const result = await response.json();
          rec.outcome = result.outcome;
          rec.resolved_at = new Date().toISOString();
          if (!rec.event) rec.event = {};
          if (homeScoreInput) {
            rec.event.home_score = Number(homeScoreInput);
          }
          if (awayScoreInput) {
            rec.event.away_score = Number(awayScoreInput);
          }
          if (closingPriceInput) {
            rec.closing_price = Number(closingPriceInput);
          }

          applyFiltersAndRender();
          statusMessage.textContent = `Marked ${rec.team || rec.bet_side} as ${result.outcome}.`;
        } catch (err) {
          console.error(err);
          alert(err.message || 'Failed to resolve recommendation.');
        }
      }

      function updateStatusSummary(filteredRecommendations) {
        const total = state.data.length;
        const filteredCount = filteredRecommendations.length;
        const loggedCount = filteredRecommendations.filter((rec) => rec.bet_logged).length;
        const totalUnits = filteredRecommendations.reduce((sum, rec) => sum + getLoggedUnits(rec), 0);
        const totalDollars = filteredRecommendations.reduce(
          (sum, rec) => sum + getLoggedAmount(rec),
          0
        );
        const refreshed = state.lastRefreshed
          ? state.lastRefreshed.toLocaleTimeString()
          : '—';
        const viewLabel = state.view === 'history' ? 'History' : 'Live';
        statusMessage.textContent = `[${viewLabel}] Showing ${filteredCount} of ${total} recommendations · Logged bets: ${loggedCount} (${totalUnits.toFixed(2)}U / ${formatCurrency(totalDollars)}) · Last refreshed ${refreshed}`;
      }

      function getLoggedUnits(rec) {
        if (!rec.bet_logged || !rec.bets) return 0;
        return rec.bets.reduce((sum, bet) => sum + (parseFloat(bet.stake_units) || 0), 0);
      }

      function getLoggedAmount(rec) {
        if (!rec.bet_logged || !rec.bets) return 0;
        const total = rec.bets.reduce((sum, bet) => sum + (parseFloat(bet.stake_amount) || 0), 0);
        if (total) return total;
        // fallback if stake_amount missing
        return getLoggedUnits(rec) * unitValue;
      }

      function formatCurrency(amount) {
        const value = Number(amount) || 0;
        return `$${value.toFixed(2)}`;
      }

      function formatLoggedSummary(rec) {
        const units = getLoggedUnits(rec);
        const amount = getLoggedAmount(rec);
        if (!units) return '0.00U ($0.00)';
        return `${units.toFixed(2)}U (${formatCurrency(amount)})`;
      }

      async function runIngestion() {
        ingestBtn.disabled = true;
        ingestBtn.textContent = 'Running…';
        try {
          const response = await fetch(`${API_BASE}/ingest`, { method: 'POST' });
          if (!response.ok) {
            throw new Error(`Failed to trigger ingestion (${response.status})`);
          }
          await fetchRecommendations();
        } catch (err) {
          console.error(err);
          statusMessage.textContent = 'Ingestion failed. Check logs and retry.';
        } finally {
          ingestBtn.disabled = false;
          ingestBtn.textContent = 'Run Ingestion';
        }
      }

      refreshBtn.addEventListener('click', () => fetchRecommendations());
      ingestBtn.addEventListener('click', runIngestion);
      limitSelect.addEventListener('change', () => fetchRecommendations());
      leagueSelect.addEventListener('change', (event) => {
        state.filters.league = event.target.value;
        applyFiltersAndRender();
      });
      bookSelect.addEventListener('change', (event) => {
        state.filters.sportsbook = event.target.value;
        applyFiltersAndRender();
      });
      confidenceSelect.addEventListener('change', (event) => {
        state.filters.confidence = event.target.value.toLowerCase();
        applyFiltersAndRender();
      });

      headerCells.forEach((cell) => {
        cell.addEventListener('click', () => {
          const key = cell.dataset.sort;
          if (!key) return;
          if (state.sort.key === key) {
            state.sort.direction = state.sort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            state.sort.key = key;
            state.sort.direction = key === 'triggered_at' ? 'desc' : 'asc';
          }
          applyFiltersAndRender();
        });
      });

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => selectView(button.dataset.view));
      });

      function selectView(view) {
        if (state.view === view) return;
        state.view = view;
        tabButtons.forEach((btn) => {
          const isActive = btn.dataset.view === view;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive);
        });
        state.sort = { key: 'triggered_at', direction: 'desc' };
        fetchRecommendations();
      }

      fetchRecommendations();
    </script>
  </body>
</html>
